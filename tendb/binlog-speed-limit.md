# TenDB binlog限速
在MySQL生成环境，应用更倾向使用一主多从，或多主的方式作为容灾方案，这些容灾方案最重要的一环就是主从复制，增量数据binlog同步。  
在binlog同步时，大多数场景下，我们希望IO线程尽可能快的将binlog同步到Slave节点执行，缩短主从的同步延时; 但在一些特殊而又经常遇到的场景，我们是希望能有一定的机制控制binlog同步的速度。  
例如一主多从场景下，随着从Slave的线性增长，Master需要将同一份binlog同步给不同的Slave节点，带来的网络带宽也是线性增长的，当IO线程耗用大量的网络带宽后，正常应用的请求也会受到影响。  
另外一个场景是新增Slave, 典型的是故障后恢复，一般新增Slave的步骤是导入全备数据，然后增量同步，例如我们使用mysqldump备份了某个时间点的全量数据，同时记录了备份的一致性点(binlog_file, binlog_file_pos), 我们会在新增Slave时先导入此备份的全量数据，然后从一致性点开始同步binlog。如果备份时间与重建Slave的时间差较大或Master产生的binlog速度过快，这个时候会存在大量的binlog需要拉取，在`START IO_THREAD`后，可能会造成短暂的网络尖峰，造成响应时间变长, 影响应用的正常请求。  
基于以上考虑点，我们希望有一些策略来限制binlog的同步速度，这样便于在一些场景能保护我们的master

## binlog限速说明
在流量限制上，主流的限流算法有漏桶算法和令牌桶算法，主要区别在于是否允许突发流量。由于我们的需求是限定binglog速度，因此只能考虑在应用层限定而不能在网路层限定。对于binlog限速来说，最小的传输单元是每个binlog事件, 由于单个event的大小并不受控制，因此采用令牌捅算法更合适。目前我们通过在Slave拉取行为上实现令牌桶算法来控制拉取速度  
令牌桶算法的原理比较简单，大致如下：  
1. 假设有一个桶，容量为n
2. 每秒加入a个令牌
3. 当一个数据包到来时它必须从桶中拿到与数据包大小相同的令牌数才能放行  

速率由a的大小来决定，能通过的最大数据包大小由n决定，原始的令牌桶算法存在丢弃数据包的行为，但是这在我们的场景下是不可接受的。因此将该算法稍作改动，让其可以通过大于n的数据包，具体改动是：如果一个event已经到达，那么即使桶满了也不丢弃溢出的令牌，这样无论多大的数据包都能获得足够的令牌数然后被放行;除此以外，令牌桶算法要求的每秒加入固定数量的令牌入桶在单线程的模型中也不易实现，因此将其修改成每次写relay_log之前加入令牌。

### 参数说明
- read_binlog_speed_limit  
作用域： SESSION|GLOBAL
默认值： 0( no-limit)  
单位： KB/s  
说明： 在Slave执行，立即生效，动态设定  


## 其他说明  
业界也有其他定制MySQL实现了binlog限速的功能，大致实现原理类似，不过采用的是Master限速。Master限速场景下，不必需要在每个Slave上都设定限速功能，但是无法做到针对某个具体的Slave限速，不能解决前文提到的新增Slave需求